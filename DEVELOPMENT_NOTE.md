This is the documentation for the process of solving this assignment.
----------------------------------------------------------------------------------------------------------------------------
# Todo task

### GET function
The first of the tasks was to find a way to get all the todos from models/todo.js, which 
is simple task by using:

```javascript
        var todo = require('./model/todo.js');

        app.get('/todos', (req, res) => {
            console.log(todo);
            res.json(todo);
        })
```
### CREATE function
Second step is add to the todo list, which is accomplisted using app.post, the resulted todo is then
sent back to the client.

```javascript
        app.post('/todos', (req, res) => {
            todo.push({
                id: todo.length+1,
                name: req.body.name,
                completed: req.body.complete
            })
            res.json(todo);
        })
```

Here a new problem arises when using Postman to test out the api: if one of the element in the body is missing,
the app can break in the future since missing elements. So a small check is added to the api call, and if the request from the client is faulty, a message is sent instead, warning of missing elements:

```javascript
        app.post('/todos', (req, res) => {
            // a block to check if enough data is supplied
            if(req.body == null || req.body.name == null || req.body.complete == null || req.body.description == null) {
                res.send('Not enough data point in todo');
                return;
            }

            todo.push({
                id: todo.length+1,
                name: req.body.name,
                description: req.body.description,
                completed: req.body.complete
            })
            res.json(todo);
        })
```

### UPDATE function
Similar to the second step, an app.put() is used together with a check:

```javascript
        app.put('/', (req, res) => {
            // a block to check if enough data is supplied
            if(req.body == null || req.body.name == null || req.body.complete == null || req.body.description == null) {
                res.send('Not enough data point in todo');
                return;
            }
            // find the id of the todo that needs to be replaced
            let index = todo.findIndex((item) => {return item.id === req.body.id});
            console.log(index);

            // check if item exists before replacement
            if(index < 0) {
                res.send('This todo does not exist');
                return;
            } else {
                let replacement = req.body;
                todo.splice(index, 1, replacement);
                console.log(todo);
                res.json(todo);
            }     
        })
```

### DELETE function
Remove an todo entry requirement is accomplised with app.delete() with a check to see if the element exists before deleting:

```javascript
        app.delete('/:id', (req, res) => {
            // check if item exists before delete
            if(todo.findIndex((item) => {item.id === req.params.id}) < 0) {
                res.send('This todo does not exist');
                return;
            }
            todo = todo.filter(todoNote => todoNote.id !== Number(req.params.id));
            res.json(todo);
        })
```

The api call for delete is using param instead. The following code is generated by Postman:

```javascript
        var myHeaders = new Headers();
        myHeaders.append("Content-Type", "application/json");

        var raw = JSON.stringify({"name":"Commit murder","completed":true,"description":"in the river"});

        var requestOptions = {
        method: 'DELETE',
        headers: myHeaders,
        body: raw,
        redirect: 'follow'
        };

        fetch("http://localhost:3000/todos/5", requestOptions)
        .then(response => response.text())
        .then(result => console.log(result))
        .catch(error => console.log('error', error));
```
Thus this is the end of the todos task of the assignment
----------------------------------------------------------------------------------------------------------------------------

# filter assignment
At this point of development, if a new filter route is added into the app.js, the application will look more complicated than it needs to be, so a better idea is to use module routing to simplify the debugging process in the future. So at this point all the todos functions are moved to /modules/todos.js then app.js will import todos.js and reroute the request there:
```javascript
        // in app.js
        var todoRouter = require('./modules/todos');
        app.use('/todos', todoRouter);

        // in modules/todos.js
        todoRouter.post('/todos', (req, res) => {
            todo.push({
                id: todo.length+1,
                name: req.body.name,
                completed: req.body.complete
            })
            res.json(todo);
        })
```

filter.js is creater as a module router then created in the same thought process as todos router. A new problem occurs: the todo variable in the original app.js, which is then moved to todos.js, is not visible to filter.js, which means if filter module import the todo.js in /models, it will not have the latest modified data.

To rectify this problem, also at the same time keep the data intact even after the server is stopped, I created a new todo.json file which contains all the data from todo.js, and can be accessed from anywhere inside the scope of the project. Now since both todos.js and filter want to access the content of the fil, it would be wise to have a seperate module to handle the file reading and writing, which is fileHander.js which contains a readFile() and writeFile() function, both of which return a promise.

```javascript
        writeFile(todo) {
                return new Promise((resolve) => {
                    fs.writeFile('./models/todo.json', JSON.stringify(todo), (err) => {
                        if (err) resolve('error') ;
                        resolve('file written done');
                    })
                })
            }

        readFile = () => {
            return new Promise((resolve) => {
                fs.readFile('./models/todo.json', 'utf-8', (err, data) => {
                    if(err) {
                        console.log(err);
                        resolve('data error');
                    }
                    resolve(JSON.parse(data));
                })
            })
        }
```

Modifications are then added to todos.js to adapt to the new change. After these are changed, the filter router is quite simple to put together using filter and sort functions on array. Then the data can be fetched from the client using a simple get request.

```javascript
        filterRouter.get('/complete', (req, res) => {
            let filehandler = new FileHandler();
            filehandler.readFile().then(todo => {
                todo = todo.filter(todoNote => todoNote.completed === true);
                res.json(todo);
            });
        })

        filterRouter.get('/alphabet', (req, res) => {
            let filehandler = new FileHandler();
            filehandler.readFile().then(todo => {
                var result = todo.sort((a,b) => a.name.localeCompare(b.name));
                
                res.json(result);
            });
        })
```
There exists one problem when todo.json is changed, the whole server resets itself. So to ameliorate this problem, a line is added to the package.json:
        "nodemonConfig": {
            "ignore": ["*.json"]
        }
----------------------------------------------------------------------------------------------------------------------------
# search assignment
The search assignment is solved with the use of search function in array:

```javascript
        searchRouter.get('/:search', (req, res) => {
            console.log(req.params.search);
            let filehandler = new FileHandler();

            filehandler.readFile().then(todos => {
                var searchResult = todos.filter(todo => {
                    return todo.description.search(req.params.search) >= 0
                })     
            
                // return result to client
                if(searchResult.length === 0) {
                    res.send('no match found');
                } else {
                    res.json(searchResult);
                }    
            });
            
        })
```
# further testing
After some testing, there are some problems with the current id generation system, which can leads to duplicate id - which should not happen since the system relies on unique id to function. Therefore, a unique id generation function is used to generate unique id, which also checks for duplicate:

```javascript
const generateRandomID = (idList) => {
    while(true) {
        var newId = getRandomIntInclusive(0, 1000)
        console.log(newId);
        if(idList.includes(newId)=== false) {
            return newId;       
        }
    }
}

// the getRandomIntInclusive is borrowed from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
function getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive 
}

```

----------------------------------------------------------------------------------------------------------------------------
# CONCLUSION
The server was hand tested using Postman making request to the server. There are other scalable solutions for testing the server such as set up unit testing with nodejs but I admit I am not very familiar with unit testing or the process of test-driven application development.

Another point is the data storage. Optimally for a larger server handling more requests, it is better to use a dedicated database manager but for this small assignment, I decided to use a json file to store the data instead, which succeeds in completing the current task.